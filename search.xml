<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式（一）——策略模式]]></title>
    <url>%2F2018%2F11%2F19%2FstrategyDesignPattern%2F</url>
    <content type="text"><![CDATA[系列关于设计模式，我之前也读过相关书籍（主要是这本《大话设计模式》）。当时边看这本书，边根据书中的一些例子写了一些博客（我的CSDN博客）。这些博客，一者现在看来大多都是流水账；二者因为在实际中运用到的设计模式真的不多（工作经历缺乏），因此也容易遗忘；三者，当初参照的书关于设计模式讲的真的不算太好，对于23种设计模式没有很明确的分类（比如重要性等），举的例子也说不上贴近现实和通俗易懂。那么前段时间（大概是618的时候），我买了一本《Head First设计模式》并且读完。这本书就我来看，水平以及对我的帮助是要高于上一本书的。并且在工作中，也确实感觉到了有熟悉设计模式的必要，因此看完后，我也生出了重新写一遍设计模式的念头。以下，便是要介绍的第一个设计模式——策略模式 Ⅰ. 什么是策略模式 策略模式就是定义一系列的算法，并将它们分别封装起来，使他们可以相互替换。策略模式使得算法以独立于客户而变化。策略模式涉及到以下几个角色： 1. 抽象策略角色：定义了具体策略需要实现的抽象方法或接口 2. 具体策略角色：封装具体的算法 3. 客户角色：内部持有策略类对象的引用 不明白没关系，来个例子就都清晰了～ Ⅱ. 举个例子以书中的“模拟鸭子游戏”为案例来具体讲述下这个模式～ 背景的这样的： 尼古拉斯·赵四是balabala公司的一名程序员。最近PM让他做一款“鸭子游戏”（很正经的游戏，游戏者可以选择不同的鸭子控制它叫或者让它游泳之类的，不过大概可能只有小朋友会玩吧 XD）。需求第一期要求做一个让鸭子叫的功能，赵四按照正常的设计逻辑，首先设计了一个鸭子Duck的超类（嗯～赵四是一个有基础OO素养的coder），在Duck类中他写了一个非抽象的quack方法（因为鸭子都会叫，那么这部分交给父类去完成）；然后还有一个抽象的display方法（毕竟不同种类的鸭子长得不一样嘛！），就像下面这样： 确定了设计方案以后，他设计了很多个类并且继承了Duck超类：普通鸭子，橡皮鸭子，绿头鸭，鸳鸯……他一口气写了这么多的类，但是好歹是完成了PM的需求，正想休息会。PM说“赵四呀，我们现在要给鸭子加上飞行的feature”。赵四：“加需求是不可能加的，这辈子都不可能加。我要是加，我赵四就从这跳下去！”PM：“我替hr和你说一声，明天去财务室报道”赵四：“我马上加班做！”赵四想，也挺简单嘛，在Duck类中加一个非抽象的fly方法就好了嘛！鸭子们都给我飞起来！ 5min后，测试妹子一脸便秘的来找赵四，“赵四，你脑子坏了么？？橡皮鸭子满屏幕地飞！”赵四：“我….”测试：“你什么你！赶紧改！”赵四看了下自己的设计逻辑，一下就找到了问题——并不是所有的鸭子都会飞，如果把飞行的行为加到父类中去实现，那就导致某些不适合该行为的子类也具有了飞行的功能。那应该怎么样做呢？赵四想到设计模式大师给他介绍过的一个设计模式——策略模式，感觉用在这个地方很合适啊！于是他将“鸭子游戏”系统通过策略模式进行修改： 首先构建鸭子的“飞行”行为接口 123public interface FlyBehavior &#123; void fly();&#125; 那么，我们可以通过实现FlyBehavior接口来创建不同的飞行行为 然后构建鸭子的“呱呱叫”行为接口 123public interface QuackBehavior &#123; void quack();&#125; 建立一个鸭子的抽象类 12345678910111213141516171819202122public abstract class Duck &#123; protected FlyBehavior flyBehavior; protected QuackBehavior quackBehavior; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; public void performQuack() &#123; quackBehavior.quack(); &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; 这是“鸭子”的抽象类，这里有一个“小心机”，在Duck类中持有着对FlyBehavior以及QuackBehavior接口的引用，并且有setter方法，那么我们就可以在使用的过程中“动态”地设定鸭子🦆的行为了！ 接下来是什么？来实现FlyBehavior吧 1234567public class FlyWithWings implements FlyBehavior&#123; @Override public void fly() &#123; System.out.println("I can fly! Flying with wings!"); &#125;&#125; 上面是一个“会飞”（而且是用翅膀飞）的飞行行为实现，再来一个“不会飞”的飞行行为（橡皮鸭子就不会飞对吧）！ 1234567public class CanNotFly implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println("Fuck! I can't fly!"); &#125;&#125; 继续建立两个QuackBehavior的实现 1234567public class Quack implements QuackBehavior &#123; @Override public void quack() &#123; System.out.println("Quack! Quack! Quack!"); &#125;&#125; 上面这是是正常鸭子的叫声（”Quack! Quack! Quack!”），接下来建立一个“咩咩咩”叫的鸭子叫行为（高贵的赵四表示他也不知道为什么会有鸭子是咩咩叫的 - -） 1234567public class MewQuack implements QuackBehavior &#123; @Override public void quack() &#123; System.out.println("Mew! Mew! Mew!"); &#125;&#125; 接下来来建立两只不同的鸭子来做模拟！ 123456789public class RubberDuck extends Duck &#123; @Override public void display() &#123; System.out.println("Hi! It's a RubberDuck!"); performFly(); performQuack(); &#125;&#125; 第一只鸭子是一只橡皮鸭子，赵四觉得还需要一只“正常”的鸭子： 123456789public class NormalDuck extends Duck &#123; @Override public void display() &#123; System.out.println("Hi! It's a NormalDuck!"); performFly(); performQuack(); &#125;&#125; 最后，最后来建立一个鸭子游戏模拟器，来模拟下！ 123456789101112131415161718192021222324public class DuckGameSimulator &#123; public static void main(String[] args) &#123; FlyBehavior flyWithWings = new FlyWithWings(); FlyBehavior cantNotFly = new CanNotFly(); QuackBehavior quack = new Quack(); QuackBehavior mew = new MewQuack(); System.out.println("************* Duck 1 *************" + "\n"); Duck rubberDuck = new RubberDuck(); rubberDuck.setFlyBehavior(cantNotFly); rubberDuck.setQuackBehavior(mew); rubberDuck.display(); System.out.println("\n" + "************* Duck 2 *************" + "\n"); Duck normalDuck = new NormalDuck(); normalDuck.setFlyBehavior(flyWithWings); normalDuck.setQuackBehavior(quack); normalDuck.display(); &#125;&#125; 看下输出的结果！ 1234567891011************* Duck 1 *************Hi! It's a RubberDuck!Fuck! I can't fly!Mew! Mew! Mew!************* Duck 2 *************Hi! It's a NormalDuck!I can fly! Flying with wings!Quack! Quack! Quack! Ⅳ. 总结设计原则：将应用中变化的部分与固定的部分分离，并把“变化”进行封装，从而不影响应用其他的部分。这样就让系统的耦合降低，系统将更有弹性。]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda+Stream对集合进行操作]]></title>
    <url>%2F2018%2F11%2F11%2FLambdaAndStreamOperate%2F</url>
    <content type="text"><![CDATA[写在前面Lambda表达式以及stream API是Java8才支持的两个功能。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），Lambda 表达式填补了Java对于函数式编程的空白；Stream API（java.util.stream）则把真正的函数式编程风格引入到Java中。两者结合可以带来很多奇妙的code体验！对很多初学者（比如我）来说，Lambda+Stream的方式一方面确实简化了代码的书写，让代码结构变得比较优雅，但从另一方面来说这样的代码风格，着实不容易看懂。但是随着实际的学习使用，我愈发感觉到这两者结合为开发带来了n多效率与快感！接下来就来探索下这种奇妙的编程style吧！ P.S. 此文不讲述最基本的lambda以及stream的概念和用法，只粗略的介绍下这种code方式在实际项目开发中的应用 假如有一个姓名的list和一个数字的list：： 12private static List&lt;String&gt; nameList = Arrays.asList("Pony", "Jack", "Gay", "Porsche", "Aston", "Maybach”);private static List&lt;Integer&gt; numberList = Arrays.asList(1, 2, 3, 4, 5, 6); ###1. 集合遍历如果要遍历nameList，传统的使用是通过for循环来实现的，如果利用lambda表达式，可以让遍历的代码变得更简洁明了： 12345678910111213// 常规方式遍历System.out.println("************ 以下为常规方式遍历list ************");for (String name : nameList) &#123; System.out.println("name:" + name);&#125;System.out.println("************ 以下为Lambda+函数操作 遍历list ************");// Lambda 函数操作nameList.forEach(name -&gt; System.out.println("name:" + name));System.out.println("************ 以下为Lambda+双冒号操作符 遍历list ************");// Lambda 双冒号操作符nameList.forEach(System.out::println); 输出结果如下：123456789101112131415161718192021************ 以下为常规方式遍历list ************name:Ponyname:Jackname:Gayname:Porschename:Astonname:Maybach************ 以下为Lambda+函数操作 遍历list ************name:Ponyname:Jackname:Gayname:Porschename:Astonname:Maybach************ 以下为Lambda+双冒号操作符 遍历list ************PonyJackGayPorscheAstonMaybach 可以看到运用了lambda表达式的遍历代码变的短小精悍。另外，我们先是用常用的箭头语法（-&gt;）创建 Lambda 表达式，然后还用了 Java 8 全新的双冒号操作符（::）。但是从输出结果上来看，双冒号操作符尽管简单，但却缺乏灵活及弹性。 ###2. filter()过滤 我们使用stream中的filter过滤器来过滤得到以”P”为开头的姓名： 12System.out.println("************ 以下为Lambda+Stream 过滤list ************");nameList.stream().filter(name -&gt; name.startsWith("P")).forEach(name -&gt; System.out.println("start with P: " + name)); 输出结果如下：123************ 以下为Lambda+Stream 过滤list ************start with P: Ponystart with P: Porsche 值得注意的是，stream的filter功能是“正向”的过滤，也就是说，是将符合filter内条件的数据“过滤”出来，而不是“排除”这些数据。 ###3. collect()方法 我们可以使用 collect 方法来将我们的结果集放到一个list，字符串， Set中: 123System.out.println("************ 以下为Lambda+Stream 过滤list 并输出为新的list ************");List&lt;String&gt; filterNameList = nameList.stream().filter(name -&gt; name.startsWith("P")).collect(Collectors.toList());filterNameList.forEach(name -&gt; System.out.println("filterName:" + name)); 输出结果如下：123************ 以下为Lambda+Stream 过滤list 并输出为新的list ************filterName:PonyfilterName:Porsche ###4. limit()限制结果集数目 我们不想要全部的结果集，只需要前面几行怎么办？easy，limit来帮忙！使用limit可以灵活限制结果集数目： 12System.out.println("************ 以下为Lambda+Stream 过滤list 并用limit 限制结果集数目 ************");nameList.stream().filter(name -&gt; name.startsWith("P")).limit(1).forEach(name -&gt; System.out.println("start with P: " + name)); 输出结果如下：12************ 以下为Lambda+Stream 过滤list 并用limit 限制结果集数目 ************start with P: Pony ###5. sorted()排序 可以看到，现在的nameList是无序的，使用sorted就可以进行简洁又灵活的排序了！我们来对nameList按照姓名的字典序进行排序吧： 12System.out.println("************ 以下为Lambda+Stream 通过名字的字典序对list排序 ************");nameList.stream().sorted((name1, name2) -&gt; (name1.compareTo(name2))).forEach(name -&gt; System.out.println("sorted name: " + name)); 输出结果如下：1234567************ 以下为Lambda+Stream 通过名字的字典序对list排序 ************sorted name: Astonsorted name: Gaysorted name: Jacksorted name: Maybachsorted name: Ponysorted name: Porsche ###6. min()和max()得到最小值及最大值 如果要获取排序后的最小值（序号最小）或最大值（序号最大）呢？使用min和max吧！ 1234System.out.println("************ 以下为Lambda+Stream 通过名字的字典序对list排序 后分别取出第一个及最后一个name ************");String minName = nameList.stream().min((name1, name2) -&gt; (name1.compareTo(name2))).get();String maxName = nameList.stream().max((name1, name2) -&gt; (name1.compareTo(name2))).get();System.out.println("minName: " + minName + ", maxName: " + maxName); 输出结果如下：12************ 以下为Lambda+Stream 通过名字的字典序对list排序 后分别取出第一个及最后一个name ************minName: Aston, maxName: Porsche ###7. map()来完成对stream中值的转换 对于numberList，我们要如何对其中每一个数进行平方运算呢？我们将 Lambda 表达式 x -&gt; x * x 传给 map() 方法，来对numberList中每一个元素进行操作。然后再打印看看吧： 123456// map将流中的一个值转换成一个新的值System.out.println("************ 以下为Lambda+Stream 使用map对numberList中对元素进行平方运算 ************");numberList.stream().map(x -&gt; x * x).forEach(System.out::println);```Java输出结果如下： ** 以下为Lambda+Stream 使用map对numberList中对元素进行平方运算 **149162536123456789###8. reduce()生成新的值对numberList中所有元素进行平方运算后，如果我们需要得到它们的和呢？我们使用 reduce() 将所有元素求和生成一个新的值：```JavaSystem.out.println(&quot;************ 以下为Lambda+Stream 使用map对numberList中对元素进行平方运算后 并用reduce生成新的值 ************&quot;);Integer newSum = numberList.stream().map(x -&gt; x * x).reduce((x, y) -&gt; x + y).get();System.out.println(&quot;newSum: &quot; + newSum); 输出结果如下：12************ 以下为Lambda+Stream 使用map对numberList中对元素进行平方运算后 并用reduce生成新的值 ************newSum: 91 以上只是介绍了Lambda+Stream对集合操作的一些简单的入门实践，希望能对你有帮助，也希望我们能在合适的地方灵活得运用它们～ 就是这样！希望你喜欢～]]></content>
      <tags>
        <tag>Lambda</tag>
        <tag>Stream</tag>
        <tag>集合</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java从Resource中读取.csv文件并进行处理]]></title>
    <url>%2F2018%2F10%2F24%2FreadResourceCSVFile%2F</url>
    <content type="text"><![CDATA[功能正常的java的maven工程中都有一个resources文件夹，里面存放着一些资源文件、spring容器启动时的xml文件等。当将一个.csv文件放到resources文件夹中，我们在代码中应该怎么读取和处理呢？ 主要步骤如下：1. 根据Resource文件所在的实际Path，用ClassLoader来获取文件的输入流inputStream2. 用字符缓冲输入流BufferedReader读取输入流inputStream3. 对文件按行顺序读取并处理 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class InformationReadTest &#123; private static final String pathName = "information_list.csv"; private static List&lt;String&gt; readResourceFile() &#123; InputStream inputStream = null; List&lt;String&gt; fileList = new ArrayList&lt;&gt;(); try &#123; // 根据Resource文件所在的实际Path，用ClassLoader来获取文件的输入流 inputStream = InformationReadTest.class.getClassLoader().getResourceAsStream(pathName); // 用字符缓冲输入流BufferedReader读取inputStream BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line = null; // 对文件按行顺序读取 while ((line = reader.readLine()) != null) &#123; fileList.add(line); &#125; &#125; catch (Exception e) &#123; System.out.println("fail! " + e); &#125; return fileList; &#125; private static String getInformation(String information) &#123; if (StringUtils.isEmpty(information)) &#123; System.out.println("input information is null!"); return null; &#125; String[] strings = information.split(","); if (strings.length != 7) &#123; System.out.println("input information format is illegal!"); return null; &#125; String result = "姓名：" + strings[0] + ", 年龄：" + strings[1] + ", 职业：" + strings[2] + ", 地址：" + strings[3] + ", 爱好：" + strings[4] + ", 取向：" + strings[5] + ", 婚恋：" + strings[6]; return result; &#125; public static void main(String[] args) &#123; List&lt;String&gt; fileList = readResourceFile(); // 用了一个lamda表达式来循环处理fileList fileList.stream().forEach(fileString -&gt; &#123; String result = getInformation(fileString); System.out.println(result); &#125;); &#125;&#125; 运行结果如下： 123姓名：王小明, 年龄：17, 职业：学生, 地址：浙江省杭州市, 爱好：健身, 取向：直男, 婚恋：没有女朋友Process finished with exit code 0 工程结构如下： P.S. main方法中用了一个Lambda表达式，这个我们在接下来对博客中会讲一讲Lambda表达式对一些用法～ 喜欢你喜欢～]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Resource</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过HttpServletResponse实现浏览器文件下载及坑点介绍]]></title>
    <url>%2F2018%2F10%2F20%2FhttpServletResponseDownloadFile%2F</url>
    <content type="text"><![CDATA[功能最近在做一个需求————通过一个Controller将相关数据转成csv文件后直接让浏览器下载。思路呢，比较清晰，主要的流程如下：1. 设置响应的ContentType类型2. 设置响应头3. 通过httpServletResponse获取ServletOutputStream对象4. 将需要的数据写到输出流中 这里给出示例代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 下载数据 */ @RequestMapping("/downloadCSVFile") public void downloadCSVFile(HttpServletResponse httpServletResponse) &#123; try &#123; // 设置ContentType httpServletResponse.setContentType("application/x-download;charset=utf-8"); // 设置文件名，并指定编码格式 String fileName = URLEncoder.encode("download_records_" + System.currentTimeMillis() / 1000 +".csv", "UTF-8"); httpServletResponse.setCharacterEncoding("UTF-8"); // 将文件名addHeader httpServletResponse.setHeader("content-disposition", "attachment;filename=" + fileName); String message = "test"; InputStream stream = new ByteArrayInputStream(message.getBytes("UTF-8")); OutputStream out = httpServletResponse.getOutputStream(); byte buff[] = new byte[1024]; int len = 0; while ((len = stream.read(buff)) &gt; 0) &#123; out.write(buff, 0, len); &#125; out.flush(); out.close(); stream.close(); &#125; catch (Exception e) &#123; logger.error("download output error!", e); &#125; &#125; 代码很简单，首先我们设置了httpServletResponse的ContentType为application/x-download，用于表面我们要传输应用程序数据或者二进制数据。随后设置response的头为content-disposition。content-disposition用来对报文体进行描述，规定了客户端的显示处理行为；有两种取值：attachment和inline，分别表示保存和直接显示。并且我们设置了文件名及保存的格式然后将我们需要的数据通过写入httpServletResponse中完成我们需要的功能。 当我们部署好以后，访问controller的域名即可完成下载。 好了，我知道这么尝试的同学都能顺利成功的。 那么我想说的问题是什么？问题是当通过前端的页面进行下载时不会出现文件下载，只会在前端的response中显示我传输的内容；而直接通过网页访问页面是可以正常下载的！ 问题的原因与解决方案原因一开始找原因是极其难的，因为我们根本不知道前端哪里出了问题。后来在一篇文章中（Javascript/jquery通过POST用JSON数据下载文件）推测了原因：前端在请求时借用了ajax来进行。但是ajax是不直接支持下载文件的，换而言之，不能直接通过向httpServletResponse写文件流并通过ajax下载！ajax支持的dataType只有如下几种:：xml、html、script、json、jsonp和text。有了如下推测，直接联系前端同学，问她（对的，是个妹子呢，前端就是妹子多）是不是用了ajax，一贴代码，果然如此～ 解决方案让前端不要通过ajax请求就好了～so easy～ ok！done！]]></content>
      <tags>
        <tag>HttpServletResponse</tag>
        <tag>文件</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Apache的Http框架以"application/x-www-form-urlencoded"形式post数据的两种方式]]></title>
    <url>%2F2018%2F10%2F13%2FhttpPostDataTranser%2F</url>
    <content type="text"><![CDATA[简介最近与第三方公司作业务对接时，需要我方将数据通过http请求的方式传输到对方接口，我方一直通过将对应的数据对象以“json”的格式放在http请求体中。联调后对方表示一直读不到数据。经过很多方式的探索后发现，对面是用“key-value”的方式在读取数据，怪不得拿不到数据！因为我们的http请求都是通过Apache的Http框架来建立的，接下里我就简单介绍下通过Apache的Http框架，以”application/x-www-form-urlencoded”形式post数据的两种方式。 这里给出示例代码如下： 两种方案1. 数据以”json”格式传输代码如下： 123456// 建立HttpPost对象HttpPost postReq = new HttpPost(url);// 设置通过contentType和请求数据来建立请求体StringEntity entity = new StringEntity(data, ContentType.create("application/x-www-form-urlencoded", characterSet));postReq.setEntity(entity);// 以下为http请求的其他配置设置等 2. 数据以”key-value”形式传输键值对的存放需要通过BasicNameValuePair对象来实现 代码如下： 1234567891011121314// 建立HttpPost对象HttpPost postReq = new HttpPost(url);// 建立一个map来存放"key-value"对Map&lt;String,String&gt; parameters =JSON.parseObject(data, Map.class);// 新建NameValuePair列表，用来存放键值对List&lt;NameValuePair&gt; NameValuePairList = new ArrayList&lt;NameValuePair&gt;();for (String key : parameters.keySet()) &#123; NameValuePairList(new BasicNameValuePair(key, parameters.get(key)));&#125;// 通过UrlEncodedFormEntity将NameValuePairList进行格式化后放入请求体中postReq.setEntity(new UrlEncodedFormEntity(NameValuePairList, characterSet));// 设置contentTypepostReq.setHeader("Content-Type", "application/x-www-form-urlencoded");// 以下为http请求的其他配置设置等 ok！done！]]></content>
      <tags>
        <tag>Apache</tag>
        <tag>Http</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Arraylist add方法的java.lang.UnsupportedOperationException异常]]></title>
    <url>%2F2018%2F10%2F01%2FArraysException%2F</url>
    <content type="text"><![CDATA[问题最近在对list进行code的时候抛出了java.lang.UnsupportedOperationException异常，且看代码： 12345678910111213141516171819202122232425262728293031public class BlogCaseTest &#123; private static Map&lt;String, List&lt;String&gt;&gt; cityMap = new HashMap&lt;&gt;(); public static void main(String[] args) &#123; String[] provinceString = &#123;"zhejiang", "zhejiang", "shanghai", "sichuan"&#125;; String[] cityString = &#123;"hangzhou", "jiaxing", "shanghai", "chengdu"&#125;; for (int i = 0; i &lt; provinceString.length; i++) &#123; cityMapInitialize(provinceString[i], cityString[i]); &#125; &#125; private static void cityMapInitialize(String province, String city) &#123; if (StringUtils.isEmpty(province) || StringUtils.isEmpty(city)) &#123; System.out.println("illegal input province or city"); return; &#125; try &#123; if (!CollectionUtils.isEmpty(cityMap.get(province))) &#123; List&lt;String&gt; cityList = cityMap.get(province); cityList.add(city); &#125; else &#123; List&lt;String&gt; cityList = Arrays.asList(city); cityMap.put(province, cityList); &#125; System.out.println("province: " + province + " city: " + city); &#125; catch (Exception e) &#123; System.out.println("province: " + province + " city: " + city + " cityMapInitialize exception! " + e); &#125; &#125;&#125; 代码很简单，首先定义一个cityMap用来存储“省份-城市”的映射，cityMapInitialize方法用来对cityMap进行初始化或者说赋值，执行main函数后，控制台输出如下： 1234province: zhejiang city: hangzhouprovince: zhejiang city: jiaxing cityMapInitialize exception! java.lang.UnsupportedOperationExceptionprovince: shanghai city: shanghaiprovince: sichuan city: chengdu 可以看到当执行到“zhejiang-jiaxing”的时候，抛出了异常 原因与解决方案原因原因很简单，请看第19-25行代码：1234567if (!CollectionUtils.isEmpty(cityMap.get(province))) &#123; List&lt;String&gt; cityList = cityMap.get(province); cityList.add(city); &#125; else &#123; List&lt;String&gt; cityList = Arrays.asList(city); cityMap.put(province, cityList); &#125; 当cityMap中没有对应的province时，我们先通过Arrays.asList来新建一个list并put到cityMap中，而当cityMap中已经存在此province的映射时，就会取出province对应的list，并将此时的city加入到list中。那么，问题就来了————通过Arrays.asList创建的list是固定大小的ArrayList。请看Arrays中asList的源码： 12345678910111213141516171819202122/** * Returns a fixed-size list backed by the specified array. (Changes to * the returned list "write through" to the array.) This method acts * as bridge between array-based and collection-based APIs, in * combination with &#123;@link Collection#toArray&#125;. The returned list is * serializable and implements &#123;@link RandomAccess&#125;. * * &lt;p&gt;This method also provides a convenient way to create a fixed-size * list initialized to contain several elements: * &lt;pre&gt; * List&amp;lt;String&amp;gt; stooges = Arrays.asList("Larry", "Moe", "Curly"); * &lt;/pre&gt; * * @param &lt;T&gt; the class of the objects in the array * @param a the array by which the list will be backed * @return a list view of the specified array */ @SafeVarargs @SuppressWarnings("varargs") public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; 解决方案很简单，创建初始的list时，不要创建如上所述的固定大小的ArrayList。如下： 12345678if (!CollectionUtils.isEmpty(cityMap.get(province))) &#123; List&lt;String&gt; cityList = cityMap.get(province); cityList.add(city); &#125; else &#123; List&lt;String&gt; cityList = new ArrayList&lt;&gt;(); cityList.add(city); cityMap.put(province, cityList); &#125; ok！done！]]></content>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BASE64编码结果存在“换行符”及解决方案]]></title>
    <url>%2F2018%2F09%2F18%2FBASE64encode%2F</url>
    <content type="text"><![CDATA[问题今天与第三方服务器进行http请求交互时，发现传入的signature与服务器signature对不上导致请求失败。后发现是在调用sun.misc包下的BASE64Encoder().encode()方法对字符串“content”进行编码时，编码结果与服务器的标准值对不上。调试后发现本地编码结果中莫名其妙混入了很多“换行符”（\t）： 12345671iIiwiU2VuZGVyQWRkcmVzcyI6Iua1i+ivleWcsOWdgCIsIlNlbmRlck5hbWUiOiLlvKDkuIkiLCJSZWNlaXZlclByb3ZpbmNlIjoi5rGf6IuPIiwiU291cmNlSWQiOiIxMjM0NTYiLCJTZW5kZXJEaXN0cmljdCI6Iuemj+eUsOWMuiIsIlJlY2VpdmVyTW9iaWxlIjoiMTUyOTk5OTk5OTkiLCJTZW5kZXJQcm92aW5jZSI6IuW5v+S4nCIsIlJlY2VpdmVyRGlzdHJpY3QiOiLlp5Hoi4/ljLoiLCJSZWNlaXZlckNpdHkiOiLoi4/lt57luIIiLCJSZWNlaXZlck5hbWUiOiLlvKDkuIkiLCJTZW5kZXJNb2JpbGUiOiIxNTE4ODg4ODg4OCIsIlNlbmRlckNpdHkiOiLmt7HlnLPluIIifQ== 原因与解决方案原因查询了发现在RFC2045中有这么一段规定： 1REQUIRES that encoded lines be no more than 76 characters long. If longer lines are to be encoded with the Quoted-Printable encoding, &quot;soft&quot; line breaks 意思就是：BASE64一行不能超过76字符，超过就会添加回车换行符。原因就是这样，下面给出解决方案。 解决方案可以通过在BASE64编码的结果后加上 .replaceAll(“\r|\n”, “”) 解决 ok！done！]]></content>
      <tags>
        <tag>BASE64</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中加载配置文件的两种方式]]></title>
    <url>%2F2018%2F09%2F08%2FspringLoadProperties%2F</url>
    <content type="text"><![CDATA[前言在实际项目开发中经常会根据不同的环境（dev,pre,online）来配置不同的类或属性，比如说根据不同的环境配置不同的zookeeper或者数据库datasource。最简单的无非就是开发人员根据不同的环境人肉去修改对应的配置，这种方式简单但却费时，且很容易出错：极其容易出现配置写错或者忘记修改对应环境配置的情况。对于要解放双手的程序员来说，这无疑是一种很low又很低效的方式。这个时候就可以用spring读取不同的环境配置文件（比如说zookeeper.properties），然后用maven的多环境打包的方法就可将对应环境的属性注入。配置文件的存在解决了很大一份重复的工作，并且也方便了我们统一管理配置。 I. 介绍两种读取配置文件的方法那么首先要解决的通过spring来读取配置文件。一般有以下几种方式可以来读取配置文件：1. 通过xml注入2. 通过@Value注解注入 1. 通过xml注入首先，我们新建一个User类： 1234567@Data@ToStringpublic class User &#123; private String name; private String city; private String phone;&#125; @Data和@ToString是lombok的注解，是为了省去写getter，setter及toString方法的神器，当然还有很多人认为lombok的注解是邪教- -，好吧，这不是咱们今天要说的重点 可以看到User类中存在三个私有变量，我们的目的就是通过资源文件中的配置来注入到这三个变量中 那么，我们来建立一个资源文件——user.properties，内容如下： 1234#useruser.name = $&#123;test.user.name&#125;user.city = $&#123;test.user.city&#125;user.phone = $&#123;test.user.phone&#125; 其中，${test.user.name}、${test.user.city}、${test.user.phone}分别对应环境资源文件中的属性。因为实际项目开发中需要根据不同的环境打包不同的环境资源文件，因此不同的环境都会对应一份环境资源文件，例如dev_config.properties对应线下开发环境，pre_config.properties对应预发环境，online_config.properties对应线上正式环境。以下我们给出线下环境的资源文件（dev_config.properties）配置： 1234#usertest.user.name = Olivetest.user.city = hangzhoutest.user.phone = 16668815388 为了让spring可以注入properties文件中的配置，首先需要在xml中配置扫描包下的java文件： 1&lt;context:component-scan base-package="com.xxx.xxx.service"/&gt; 然后需要在spring的xml配置文件中添加以下两个类的实例，这两个类用来加载prperties文件，这两个类真的很重要！已经遇到无数起因为没有配置这俩类导致的大坑： 12org.springframework.beans.factory.config.PropertiesFactoryBeanorg.springframework.beans.factory.config.PreferencesPlaceholderConfigurer 配置如下： 1234567891011&lt;bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath*:message.properties&lt;/value&gt; &lt;value&gt;classpath*:user.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"&gt; &lt;property name="properties" ref="configProperties" /&gt;&lt;/bean&gt; list标签的value写明了要扫描的properties文件的名字，当然也可以暴力地扫描所有properties文件： 1&lt;value&gt;classpath*:*.properties&lt;/value&gt; 接下来我们就可以注册User的bean，然后将对应属性注入到类的私有域中： 12345&lt;bean id="user" class="com.mogujie.trade.third.service.sync.User"&gt; &lt;property name="name" value="$&#123;user.name&#125;"/&gt; &lt;property name="city" value="$&#123;user.city&#125;"/&gt; &lt;property name="phone" value="$&#123;user.phone&#125;"/&gt;&lt;/bean&gt; 然后我们写个单测跑一跑： 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath*:spring-biz.xml"&#125;)public class UserTest &#123; @Autowired private User user; @Test public void testUserProperties() &#123; System.out.println("System out: " + user.toString()); &#125;&#125; 看下结果： 1System out: User(name=Olive, city=hangzhou, phone=16668815388) ok！done！ 2. @Value注解要使用@Value注解，那么我们首先要对User类做出修改，因为之前是通过xml注册user bean，现在则需要显式地用@Service修饰User类，并且给User类的私有域都加上@Value注解（此时就不用通过xml来注册user bean）： 1234567891011@Service("user")@Data@ToStringpublic class User &#123; @Value("$&#123;user.name&#125;") private String name; @Value("#&#123;configProperties['user.city']&#125;") private String city; @Value("$&#123;user.phone&#125;") private Long phone;&#125; 重新跑下单测，成功了～结果和上面一样的，就不贴出来了 另外， 我们可以看到在city上的@Value注解用的是”#{}”，了解@Value注解的同学可能知道有两种设置属性值的方法：@Value(“#{}”)与@Value(“${}”)。那么这两种方式有什么区别呢？ 2.1 @Value(“#{}”) SpEL表达式@Value(“#{}”) 表示SpEl表达式通常用来获取bean的属性，或者调用bean的某个方法。当然还有可以表示常量。@Value(“#{configProperties[‘user.city’]}”)注解中有configProperties，指的是配置文件的加载对象，即我们最开始强调的要在xml中注册的configProperties bean 2.2 @Value(“${t1.msgname}”)这种形式不需要指定具体加载对象，这时候需要实例化PreferencesPlaceholderConfigurer类对象。此对象配置可以可以直接复用configProperties对象中的配置，也可以自定配置文件路径。可以看到，我们在一开始就注册了这个bean。 有兴趣的同学可以验证一下上面两个配置文件（我当然验证过了咯:D） done！ II. 相关博客推荐[1]. Spring注入值（Value注解）[2]. spring(基础10) 注解@Value详解]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引及查询优化（三）——索引设计概述]]></title>
    <url>%2F2018%2F09%2F04%2FsqlIndexAndQueryOptimize-3%2F</url>
    <content type="text"><![CDATA[写在前面终于写到这个系列最后一篇文章了，前两篇第一篇通过慢查询日志分析了sql语句，第二篇讲述了索引等概念、类型，并且讲述了如何通过explain指令来对sql进行分析，最后也给出了一些查询实例。今天第三篇，主要会讲下mysql中索引的普适性设计方案（比如三星索引等概念及设计思路）以及评判索引性能的两种方法。 Ⅰ. 基本概念与假设1. 对db表的读取： 从磁盘中进行一次随机I/O，即将一个页从磁盘中读取至数据库缓冲池：大约10ms 从磁盘服务器的缓存中进行读取，当dbms需要的页不在数据库缓冲池中，会向磁盘服务器发起请求，服务器首先回去查询此页是否在缓冲区中，若在缓冲区中，读取的时间将大幅降低：1ms 对磁盘进行顺序读取，上面说的都是将一个表页读取到缓冲池的情况，很多时候我们会需要读取多个页到缓冲池中，然后进行顺序处理，同时读取多个页将减少每个页被平均读取的时间：0.1ms 2. 访问dbms读取一个索引行或一个表行称为一次访问：索引访问或表访问。若dbms扫描索引或表的一个片段（被读取的行在物理上相邻），那么第一次读取为随机访问（TR），后续行的读取为顺序访问（TS）。 3. 谓词where语句中的条件被称为 谓词 4. 索引片及匹配列索引片是sql查询在执行过程中扫描的一个索引片段，在这个范围中的索引将被顺序扫描；索引片的厚度指 谓词表达式确定的范围，索引片越窄说明匹配到的数据行数越少，那么索引访问及对表的读取的开销越小。另一种广泛描述索引片的方法是定义 索引匹配列的数量。 5. 索引匹配列和过滤列有些列可能同时存在于where子句中与索引中，但是这个列所在的索引却不能生效（比如之前所说的，where子句中碰到范围查询，其后的索引列将不生效），这样的列称为过滤列，因为通过索引上的过滤列能够避免回表访问。与过滤列相对的，如果where条件中的一列同时在索引中，并且能参与索引的定义，那么这列就是匹配列。 6. 过滤因子其描述了谓词的选择性，即满足where条件的记录占所有记录总数的比例。在评价索引是否合适时，过滤因子很重要。并且在实际中，一般考虑最差情况下的过滤因子，而不是平均过滤因子。 Ⅱ. 最优索引概念及设计思路1. 三星索引三星索引是一个概念，表示对于一个查询来说最理想的索引。既然是三星索引，那必然是有三颗星，那么星级如何确定呢？如果与一个查询相关的索引行是相邻的，或者至少足够靠近的话，那这个索引就可以被标记上第一颗星。这最小化了必须扫描的索引片的宽度； 如果索引行的顺序与查询语句的需求一致，则索引可以被标记上第二颗星。这排除了排序操作； 如果索引行包含查询语句中的所有列——那么索引就可以被标记上第三颗星。这避免了访问表的操作，仅访问索引就可以了。 对于这三颗星，第三颗通常是最重要的（其实这里的说明很理论也很拗口，下面会给出具体例子来说明）。 2. 宽索引与窄索引宽索引是指一个至少满足第三颗星的索引，此索引包含了select语句所涉及的所有列，因此该查询只需访问索引而不必回表查询。 3. 举个三星索引设计的栗子：比如说如下的一条sql： 1select sex from user where name=“jack” and city=“hangzhou” order by age 第一颗星：取出所有等值谓词的列（即where条件后的列：name和city），将name和city作为索引的开头，并且不要求严格的顺序。这可以使索引片宽度缩短至最窄 第二颗星：将用来排序的列（oder by age）加入到索引中。那现在索引就变成：name_city_age 第三颗星：将查询语句剩余的列加到索引中去，列在索引中的顺序对查询性能无影响。此时索引将变成name_city_age_sex，这个索引就是三星索引 4. 索引星级的选择能设计出三星索引，无疑是最好的情况（不考虑存储索引等的开销），但在很多实际情况下，是无法设计出理想的三星索引的。换句话说，对于索引的某些星级我们必须要进行舍弃。 举个例子： 1select sex from user where age between a and b and city=“hangzhou” order by name 在这个sql中，age是一个范围条件，在前面的博客中（mysql索引及查询优化（一）——从慢查询实例中开始分析）我们说过，如果索引列是一个范围条件，那么其后的索引都将失效。那这个时候索引该如何设计？在前面说过，索引的第三颗星通常是最重要的，那么我们先设计第三颗星，索引将是：*_user。添加name会让索引满足第二颗星，但这是基于name必须在范围谓词age的前面的假设的，那么此时索引将变成:name_age_sex或者city_name_age_sex，那么此时的索引满不满足第一颗星的，答案是不满足的。讲到这里，我们一定能发现，第一颗星和第二颗星是存在互斥的，如果要满足第一颗星，那么索引将是city_age_name_sex，然而此时name列索引是不会生效的，此时就无法避免排序，也即无法满足第二颗星。综上所述，在这种情况下，我们是无法设计出理想的三星索引的，我们必须要进行取舍。至于是选第一颗星还是第二颗星，一个普遍的结论（虽然并不是完全正确的）是第一颗星要比第二颗星重要，因为在硬件发展水平如此快速的今天，可能排序带来的开销远低于因为索引片太厚而带来的查询开销。 另外，虽然理论上为每一个查询都设计出最优的索引看似是比较好的，然而真正这么做的时候我们需要考虑下开销：首先过多的索引会占用大量的磁盘空间，我们需要评估索引带来的收益是否能抵消磁盘空间带来的开销；其次表上有太多的索引（并且这些索引可能存在冗余），会使db的插入、更新与删除操作变得较慢；最后，较频繁的插入频率，可能会加大磁盘的负载。所以，理论终究只是理论，具体问题还需要具体分析。 Ⅲ. 如何设计及评估索引性能首先给出两个快速且有用的方法：1. 基本问题法（Basic Question, BQ）2. 快速上限估算法（Quick Upper-Bound Estimate, QUBE） 1. 基本问题法BQ是一个很简单很快速的评估方法，对于每一个查询语句，首先都要问这么一个问题： 是否存在一个索引包含了where子句所用到的所有列？如果答案是不存在，那么应该考虑将缺少的列加入到现有的索引中去。此时会产生一个半宽索引，虽然这样索引只能拿到一星，但索引过滤可以保证回表访问只发生在所有查询条件都满足的时候。如果性能还不够，那么可以将查询所有涉及到的列都加到索引上，这会产生一个避免所有表访问的宽索引。如果查询还是很慢，那么就重新设计索引～ 2. 快速上限估算法。相比于BQ，QUBE是一个比较耗时的方法，但是它的优点也很明显——QUBE可以估算出查询的性能。QUBE通过计算本地响应时间（LRT）来评估查询的性能。我们只使用TR（随机访问的数量）和TS（顺序访问的数量）来进行查询耗时的估算。 QUBE中假设单次随机访问的时间为10ms，顺序随机访问的时间为0.1ms 3. QUBE示例： 3.1 主键索引访问：考虑如下的sql（假设id为主键）：select id, age, city from user where id = xxx通过主键索引读取一个表行需要分别随机访问一次表以及索引，因此此查询的开销大约是2x10ms=20ms。3.2 聚簇索引访问： 1select id, age from user where city = xx and post = xxx order by age 假如city_post_age是一个聚簇索引，并且杭州市内邮政编码为xxx的用户有1000个，可以通过三星索引法分析这个索引是两星的（第一颗及第二颗），但是是不满足的第三颗星的，它必须回表去访问不在索引列中的列。首先，需要进行一次随机访问找到索引片上第一条符合条件的索引行，这是一次TR，然后需要1000次TS来读取索引，因此读取索引片的开销为1x10ms+1000x0.01ms=20ms；然后来计算回表的开销，回表需要一次TR，以及999次TS，所以回表的开销大约也是20ms。因此这条sql总的耗时大约是40ms。3.3 非聚簇索引访问：还是如上的sql，如果city_post_age不是一个聚簇索引，那么我们知道，回表的访问将变成1000次的TR，此时回表的耗时将是10s！此时可以考虑将id加入到索引city_post_age中，这样便省去了回表查询的开销。 Ⅳ. 总结这次我们首先定义了一些假设及概念，然后提出了“三星索引”的概念及设计思路，最后讲述评估索引性能的两个方案。总的来说，我认为这里所提出的索引设计及评估的方案都是简单易用的，有兴趣的不妨试试看。BTW，其实我觉得explain也是一个很好的分析性能的方法，在索引建立完之后，不妨使用explain来分析下查询的性能～ Ⅴ. Reference[1]. Lahdenmaki T, Leach M. Relational Database Index Design and the Optimizers[M]. Wiley-Interscience, 2005.[2]. Schwartz B, Zaitsev P, Tkachenko V. High Performance MySQL: Optimization, Backups, and Replication[M]. O’Reilly Media, Inc. 2012.]]></content>
      <tags>
        <tag>sql</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引及查询优化（二）——索引概述]]></title>
    <url>%2F2018%2F08%2F30%2FsqlIndexAndQueryOptimize-2%2F</url>
    <content type="text"><![CDATA[写在前面隔了那么久，终于写了索引及查询优化的第二篇博文，确实用了好长的时间去看书，看博客然后总结。然而，不得不说我之前对sql以及索引相关的知识了解确实甚少（并且在实际中用的也不太多），因此即使补充了一些相关知识， 写出来的文章也会有很多的不足与纰漏。在此也希望从文章中看出有什么不足的朋友可以尽情批评指正～这篇博客主要分三个部分，第一部分简单介绍了索引的概念及类型；第二部分介绍了如何通过Explain指令分析sql；第三部分给出了一些sql的实例。 Ⅰ. 索引概念及类型1 索引概念索引是存储引擎用来快速找到记录的一种数据结构。类似于书目录，如果我们想要找“第三章第四小节”的内容，那么我们首先先从目录中找到其所在的页数，然后再从具体的页中找到我们需要的数据。索引也是一样，在查询时，先找到索引所在的位置，然后根据索引匹配到的记录来找到对应的数据。 2 索引类型 2.1 b-tree索引b-tree索引是mysql引擎中用的较多的一种类型，大多数的引擎都支持，除了archive引擎（对这个好陌生 - -）。不同的存储引擎使用不同的b-tree索引，并且性能也有差别。比如在innodb引擎中使用b+tree索引。myisam引擎会对索引进行前缀压缩，所以索引很更小；myisam中索引通过数据的物理位置来引用索引行，而innodb中根据主键引用索引行。b-tree索引对索引按照顺序组织存储的，因此适合查找范围数据。 B-tree索引在实际开发中是用的最多最广泛的索引结构，之后的讨论都默认是以B-tree索引为例。在某些不当的查询或者索引的使用中会导致索引失效，主要有以下这几种情况： 严格遵循最左匹配原则。即查询必须从索引的最左前列开始。比如一个索引(name_age_dob)，如果要查询age=18的用户，就无法使用(name_age_dob)这个索引了。 不能跳过索引中间的列。比如我们要查找age=18并且dob=1024的用户，但不指定age，那么就无法使用到(name_age_dob)索引，只能使用索引的第一列。 查询中某个列出现了范围查询，那么它右边的列都无法通过索引来进行优化查询。这在前一篇博客（xxxx）中就讲述过。 索引字段上使用了（!= &lt;&gt; is null is not null or 或者like以”%_” 开头）等会导致索引失效而转入全表扫描 对索引列进行操作（这里指索引列不能是表达式的一部分，也不能是函数的参数），比如下边的sql就不能使用索引，明眼人一看就知道id=1023啊，然而Mysql引擎并不会那么的智能，所以我们在查询时能简化条件就简化条件，越简单越好。 1select id from user where id+1=1024 2.2 哈希索引哈希索引基于哈希表实现，mysql引擎中只有memory支持哈希索引，我们知道哈希表会存在“哈希碰撞”的问题，memory引擎根据链表法来解决键值冲突的情况。类比于哈希表，使用哈希索引查找的速度十分快。但也有一些限制： 哈希索引只包含哈希值以及行指针，不存储具体字段的值，所以不能根据匹配索引来避免读取表行 哈希索引的数据不是按照索引值顺序存储的，因此无法用于排序（这个应该很好理解） 哈希索引因为是根据对key进行hash来查找的，因此不支持部分索引匹配的情况。 哈希索引不支持范围查询，只支持等值查询（注意IN()也是一种等值查询！） 上面说到了哈希碰撞，如果碰撞过多，哈希索引的性能将受很大的影响 2.3 全文索引全文索引查找的是文本中的关键词，而不是直接比较索引中的值。用的不多（我根本没用过），这也不是我想说的重点，所以不详细展开。 2.4 聚簇索引首先，聚簇索引并不是一种简单的索引类型，而是一种数据存储方式。在innodb中，聚簇索引实际在一个结构中同时保存了b-tree索引以及数据行。 聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。因为一张表只有一个物理结构，因此一张表也只能有一个聚簇索引。聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，并且有指向对应数据块的指针。innodb默认会以主键作为聚簇索引，如果没有定义主键，innodb会选择一个唯一的非空索引来代替。如果前面的情况都不满足，那么innodb会隐式定义一个主键来作为聚簇索引。 2.5 覆盖索引覆盖索引（Covering Index）也不是常规意义上的索引。如果一个索引包含了所有查询需要的字段，那么久称这个索引为“覆盖索引”。使用“覆盖索引”可以极大提高查询性能。 Ⅱ. SQL分析在进行sql分析时，explain语句是一个常用的方法，我们将举出一些sql的查询来进行分析，以下的例子都来自于Refund表（这张表与第一篇博文中使用的表相同，地址：mysql索引及查询优化（一）——从慢查询实例中开始分析） explain得到的结果分析: 请看下图的例子： 首先我们来解释下explain结果的各个列的含义： id:表示select子句执行的id，如果是子查询，id的序号就会递增了，并且id值越大的子句越先被执行 select_type:表示select语句的类型，比如：SIMPLE（简单查询，不包含子查询或者UNION）；PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY，具体不展开了，可以自行搜索 table:当前执行的表名 type：当前表内访问方式，访问方式从好到坏排序为： system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; allsystem指表只有一行记录；const表示查询了一次就找到结果；eq_ref表示唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配；ref表示非唯一索引扫描；range 表示只检索给定范围的行，使用一个索引来选择行；index表示查询扫描了索引树；all表示全表扫描 possible_keys:可能使用到的索引 key:经过优化器评估最终使用的索引 key_length:使用到的索引长度 ref:引用到的上一个表的列rows:要得到最终记录索要扫描经过的记录数，rows值越小说明查询越高效 Extra:额外的信息说明，主要的类型有：Using filesort：文件排序，说明mysql无法利用索引完成排序Using temporary：临时表， 使用了用临时表保存中间结果，MySQL在对查询结果排序时使用临时表，这个时候效率是极其低下的Using index：表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了回表访问数据Using where：使用了where过滤Using join buffer：使用了连接缓存impossible where：where子句的值总是false，不能用来获取任何元组Using index condition：Using index condition 会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行 Ⅲ. 实例分析请看如下的sql：1explain select* from Refund where sellerUserId=93106308 因为索引无法覆盖查询所需要的全部列，因此Extra中显示“Using index condition”： 再看这个SQL：1explain select status from Refund where status=700 order by created 这里进行了文件排序： 覆盖索引查询：1explain select sellerUserId, status, created from Refund Refund表中有一个多列索引：KEY idx_sellerUserId_created_status (sellerUserId,created,status)，如果只访问sellerUserId, status, created这三列，查询将使用“覆盖索引”：具体执行结果如上图所示，在type列中显示了“index”，这表示此次查询将通过索引来访问数据；Extra中的“Using index”表示此次查询将使用“索引覆盖”查询。 最后一个sql例子：1explain select status from Refund where sellerUserId=93106308 order by created 这句sql中的Extra不仅出现了“Using index”还出现了“Using where”，这表示索引被用来执行索引键值的查找；如果没有同时出现“Using where”，表明索引用来读取数据而非执行查找动作。 Ⅳ. Reference[1]. EXPLAIN用法和结果分析：https://blog.csdn.net/why15732625998/article/details/80388236[2]. Schwartz B, Zaitsev P, Tkachenko V. High Performance MySQL: Optimization, Backups, and Replication[M]. O’Reilly Media, Inc. 2012.]]></content>
      <tags>
        <tag>sql</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正式告别CSDN]]></title>
    <url>%2F2018%2F08%2F08%2F20180808-sayByeToCSDN%2F</url>
    <content type="text"><![CDATA[终于有了自己的博客CSDN拜拜👋～无数次被csdn蠢哭！一是愚蠢的人工审核方式；二是捉急的app后台，老奔溃。老实说，之前12306是我见过的最傻最蠢的app！好了，csdn刷新我记录了。现在我把这个title颁给您！请您务必接受！BTW，现在终于也搭建了自己的博客～ blog4olive.top域名不算好听（穷困的我这辈子都买不起好听的域名！可以考虑给我众筹。刚好添加了打赏功能，文章末尾即可看到！），但胜在简单明了对吧？ 关于博客更新 增加了文章pv 博客pv的显示 页脚icon等的优化 文章结构显示 文章搜索功能 打赏 TODO: 评论功能 分享 代码高亮等格式优化 更美观更优雅 之后csdn的博客都要迁移过来，工程量巨大，想打人 那么继续加油吧! 送上一张美照，改天（月？年？）继续出去旅行]]></content>
      <tags>
        <tag>随便写写</tag>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引及查询优化（一）——从慢查询实例中开始分析]]></title>
    <url>%2F2018%2F08%2F04%2F20180804-sqlIndexAndQueryOptimize-1%2F</url>
    <content type="text"><![CDATA[官方吐槽为什么写这个写这个博客也算是阴差阳错。上次做了个需求：退款列表导出（可以翻翻之前的博客，有写）。虽然事情过了那么久，现在我还是想要吐槽下，这个需求是真的有很多坑，但话说回来，做难事才会有所得，踩的坑越多，那成长就越多（请脑补虐主文）。 关于这个系列的博客这个博客大概是这么分布的：第一篇就根据实际场景来分析下索引及查询上的优化；第二篇和第三篇（如果我还能写得出来第三篇的话😅）来系统地整理下mysql的索引及查询的优化。 ———————————— 以下为正文 —————————————问题是这样的，有一次一个客服同学急急忙忙来找我，说导出几条记录都失败了，查看了错误日志显示错误如下： 好了，不要盯着人家的红色框框看了，重点不是那里。 重点是出现了慢查询日志，我知道看图肯定看不出来这条sql是啥，于是我贴心的贴了出来： 1234567select* （这里其实不是这么暴力地拿全列数据，为了方便，就*表示了）from RefundFORCE INDEX (idx_sellerUserId_created_status)WHERE sellerUserId = 40955202 AND status IN (800, 900) AND created &gt;= 946656000 AND created &lt; 2051193600 ORDER BY created desc LIMIT 0, 50 首先来分析下这条sql要做啥，其实就是在Refund（退款表）这个表中查询所有sellerUserId为40955202，并且状态在800及900（800，900等表示退款处于的状态，如退款申请，退款完成等）之间的，并且创建时间大于等于946656000且小于2051193600（这是两个时间戳）的所有记录，并且将所有这些记录根据created（创建时间）进行逆序排序后取开头50条。注意到这个sql有一个 FORCE INDEX (idx_sellerUserId_created_status)，这个意思是让sql强制走idx_sellerUserId_created_status这个索引，至于为什么有时候需要强行走索引，这个涉及到mysql的查询优化，之后会讲到 看了上面这条sql，有没有发现什么问题？可能我们会觉得有问题，但是并不能很清晰地说出来。那么，首先来看下mysql的执行计划吧！ 看出问题来了么？在我看来，这条sql至少存在3条问题！以下一条一条来分析： cerated的时间查询范围过大，946656000转化为北京时间是2000/1/1 0:0:0，2051193600转化为北京时间是2035/1/1 0:0:0。那么这个时间段段含义是什么呢？在我应用的具体执行中，当用户在导出退款列表时没有选择导出的时间段时，就会给定一个默认的搜索时间段，而恰巧我设置了比较大的起止时间。这个时间段本来是不需要这么大的，这个时间段基本将这个用户所有的退款记录都包含了。我们来看下这个用户究竟有多少条退款记录：好家伙，1000多w条记录。。那么有人会说，时间段大也没关系，不是还有其他索引项可以进行约束吗？那么我们来看看第二个问题 索引真的用上了么？为了防止mysql优化器出现石志行为，这条sql特意告诉mysql：您啥也不用想！就用这个索引！那么我们来看下这个索引：idx_sellerUserId_created_status。很明显，这是一个多列索引，是一个由sellerUserId、created、status三列组成的一个联合索引。再来看下这条sql的where条件：WHERE sellerUserId = 40955202 and status IN(800, 900) and created &gt;= 946656000 AND created &lt; 2051193600 order by created。乍一看，好像索引没用上啊？索引的排序是sellerUserId、created、status，而where条件的顺序是sellerUserId、status、created。那索引是不是没用了？当然不是的！mysql如果连这点优化都没有考虑，那和咸鱼有什么区别？？在这里，mysql会将where条件做一个优化，where条件内的顺序是不影响此索引的使用的。那么这个索引真的生效了么？事实是并没有。我们来分析下这个索引，注意看这个条件：created &gt;= 946656000 AND created &lt; 2051193600，很明显这是一个范围查询，而在多列索引的使用中，如果碰到了范围条件，那么存储引擎是不会使用范围条件右边的列的，也就是说，咱们这条sql，索引到了idx_sellerUserId_created就到头了，不会再使用status做索引。强制走的这个索引，失效了！因此这条查询只用到部分的索引 查询真的有必要那么写么？我们可以看到where条件中限制了created字段的查询范围，而在排序时又需要根据created字段进行逆序排序，之后又只取了最终结果的开头50行。尽管我们很理想化地设想mysql只会返回我们需要的数据，比如在这条sql中我们真的很希望mysql可以只扫描50行就搜索我们需要的那50条数据。然而，在真正的查询中我们惊人地发现mysql读取了超过千万条的数据！一部分的原因在于查询过程中使用了不太合适的索引，另一方面在于我们的查询太累赘了，要想我们的查询不那么累赘，首先要搞清楚我们要查询什么。如上就分析过，我们需要的只是该用户创建的、处于某些状态的、最新的50条记录，那么在这种情况下created字段的范围还有什么意义？ 那么针对上面几个问题，接下来我们想办法来优化下这条查询吧！以上的截图和问题都来源于线上，因为接下来的操作可能会涉及到表结构，所以接下来使用一个线下的db来进行模拟 首先看下表的结构 然后我们来查询下退款数量最多的用户 我们发现id为93106308的用户退款数量最多，大概有5w多行，那么就用他来做模拟吧！ 首先来模拟下最初的sql语句 12345678explain select* FROM Refund FORCE INDEX (idx_sellerUserId_created_status) WHERE sellerUserId=93106308 and status IN (700, 900, 1000) AND created &gt;= 1278691200 AND created &lt; 1531152000 ORDER BY created desc LIMIT 0, 10 如上图所示的执行结果，我们可以看到，mysql确实使用了idx_sellerUserId_created_status这个索引（这其实是废话，你都强制人家走了，，），然后看rows这一行：64867！存储引擎扫描来6w多行才得到我们需要的数据！可以看到在Extra这一列中显示的是：Using index condition，这表示查询部分使用了索引，对于不在索引中的列需要回表查询数据，这也如我们预想的那样 那么我们来试试存储引擎的自动优化吧： 哈哈，存储引擎的查询优化其实并没有想象中的那么好（但也没那么差），去除了强制索引后存储引擎自己找到了一个它认为的最优的索引：idx_created，可以看到Extra这一列中显示的是：Using where，这表示查询需要回表捞数据以后再使用where条件来进行过滤。那么和上面的情况做对比，在性能上其实是毫无差别。 那我们在索引上来优化下吧，为了避免遇到范围查询而使右边索引列失效，我们来将idx_sellerUserId_created_status索引修改为idx_sellerUserId_status_created，并且让存储引擎强制走这个索引： 发现变化了么？查询扫描的行数少了很多！ 那接下来再优化下查询语句： 可以看到，因为优化了查询语句，根据created进行逆序排序，导致最后扫描的行数大为减少！ 在这里，这条查询的优化并不是在任何场景下都是能保证有很高的查询性能的。我们知道索引在db中维护了一个b+tree 结构（innodb引擎默认结构）。idx_created索引将所有的数据根据created来建立了一个b+tree，当我们要查询的用户数据恰好在b+tree的后方的时候，查询也是需要扫描不少行的： 所以不同的数据库的数据结构需要具体的分析，如果没有对表结构以及数据结构有较清晰的认识，我认为这种查询优化是不太行的，有时候甚至会起到反面效果。 所以综合考虑，我还是建议修改下索引结构即可，至于为什么不是直接增加一个索引，这是为了减小存储引擎的压力，过多的冗余索引也给维护带来负担 接下来的博客会系统地讲述下mysql的索引及查询优化 对上述问题有问题或者想一起讨论的朋友可以随时联系～]]></content>
      <tags>
        <tag>sql</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>优化</tag>
      </tags>
  </entry>
</search>
